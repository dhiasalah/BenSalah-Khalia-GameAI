\documentclass[12pt,a4paper]{article}

% ==================== PACKAGES ====================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tcolorbox}
\usepackage{booktabs}
\usepackage{array}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{float}

% ==================== CONFIGURATION ====================
\geometry{margin=2.5cm}

% Couleurs personnalisées
\definecolor{primarycolor}{RGB}{0, 102, 204}
\definecolor{secondarycolor}{RGB}{51, 51, 51}
\definecolor{accentcolor}{RGB}{255, 153, 0}
\definecolor{codebackground}{RGB}{248, 248, 248}
\definecolor{codekeyword}{RGB}{0, 0, 255}
\definecolor{codecomment}{RGB}{0, 128, 0}
\definecolor{codestring}{RGB}{163, 21, 21}

% Configuration des hyperliens
\hypersetup{
    colorlinks=true,
    linkcolor=primarycolor,
    filecolor=primarycolor,
    urlcolor=primarycolor,
    citecolor=primarycolor,
    pdftitle={Rapport - Jeu Mancala IA},
    pdfauthor={KHALIA Mohamed Mehdi, BEN SALAH Mohamed Dhia},
}

% Configuration des listings pour C++
\lstdefinestyle{cppstyle}{
    language=C++,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    keywordstyle=\color{codekeyword}\bfseries,
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    frame=single,
    framesep=5pt,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showspaces=false,
    showstringspaces=false,
    captionpos=b,
    morekeywords={Color, GameState, Move, Evaluator, BFSBot, DFSBot, MinMaxBot, AlphaBetaBot, IterativeDeepeningDFSBot}
}
\lstset{style=cppstyle}

% En-têtes et pieds de page
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textcolor{primarycolor}{\textbf{Jeu Mancala - IA Game Programming}}}
\fancyhead[R]{\textcolor{secondarycolor}{M. Mehdi \& M. Dhia}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{2pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{primarycolor}\leaders\hrule height \headrulewidth\hfill}}

% Styles des sections
\titleformat{\section}
{\color{primarycolor}\normalfont\Large\bfseries}
{\thesection}{1em}{}[\color{primarycolor}\titlerule]

\titleformat{\subsection}
{\color{secondarycolor}\normalfont\large\bfseries}
{\thesubsection}{1em}{}

\titleformat{\subsubsection}
{\color{secondarycolor}\normalfont\normalsize\bfseries}
{\thesubsubsection}{1em}{}

% Boîtes personnalisées
\tcbuselibrary{skins,breakable}

\newtcolorbox{infobox}[1][]{
    colback=blue!5!white,
    colframe=primarycolor,
    fonttitle=\bfseries,
    title=#1,
    breakable
}

\newtcolorbox{warningbox}[1][]{
    colback=orange!5!white,
    colframe=accentcolor,
    fonttitle=\bfseries,
    title=#1,
    breakable
}

\newtcolorbox{algorithmbox}[1][]{
    colback=gray!5!white,
    colframe=secondarycolor,
    fonttitle=\bfseries,
    title=#1,
    breakable
}

% ==================== DOCUMENT ====================
\begin{document}

% ==================== PAGE DE TITRE ====================
\begin{titlepage}
    \centering
    
    % Logo de l'université (placeholder - remplacer par le vrai logo)
    \begin{tikzpicture}
        \draw[fill=primarycolor, rounded corners=5pt] (0,0) rectangle (3,1.2);
        \node[white, font=\bfseries] at (1.5, 0.6) {UNIVERSITÉ};
    \end{tikzpicture}
    
    \vspace{0.5cm}
    
    {\large\textcolor{secondarycolor}{Master 1 - Intelligence Artificielle}}
    
    \vspace{0.3cm}
    
    {\large\textcolor{primarycolor}{\textbf{UE : IA Game Programming}}}
    
    \vspace{1.5cm}
    
    \rule{\textwidth}{1.5pt}
    \vspace{0.5cm}
    
    {\Huge\textcolor{primarycolor}{\textbf{Jeu Mancala à 16 Trous}}}
    
    \vspace{0.3cm}
    
    {\LARGE\textcolor{secondarycolor}{Implémentation d'Intelligences Artificielles}}
    
    \vspace{0.3cm}
    
    {\Large\textit{Version C++}}
    
    \vspace{0.5cm}
    \rule{\textwidth}{1.5pt}
    
    \vspace{1.5cm}
    
    \begin{tikzpicture}
        % Représentation stylisée du plateau Mancala
        \foreach \i in {1,...,8} {
            \draw[fill=primarycolor!20, draw=primarycolor, thick] (\i*1.2, 0) circle (0.4);
            \node at (\i*1.2, 0) {\small\i};
        }
        \foreach \i in {9,...,16} {
            \pgfmathtruncatemacro{\x}{\i - 8}
            \draw[fill=accentcolor!20, draw=accentcolor, thick] (\x*1.2, -1.2) circle (0.4);
            \node at (\x*1.2, -1.2) {\small\i};
        }
        % Graines
        \foreach \i in {1,...,8} {
            \fill[red!70] (\i*1.2-0.1, 0.15) circle (0.08);
            \fill[blue!70] (\i*1.2+0.1, 0.15) circle (0.08);
            \fill[gray!50] (\i*1.2, -0.15) circle (0.08);
        }
    \end{tikzpicture}
    
    \vspace{1.5cm}
    
    % Auteurs
    \begin{tcolorbox}[colback=gray!5, colframe=primarycolor, width=0.8\textwidth, arc=3mm]
        \centering
        {\large\textbf{Réalisé par :}}
        
        \vspace{0.4cm}
        
        {\Large\textcolor{primarycolor}{\textbf{KHALIA Mohamed Mehdi}}}
        
        \vspace{0.2cm}
        
        {\Large\textcolor{primarycolor}{\textbf{BEN SALAH Mohamed Dhia}}}
    \end{tcolorbox}
    
    \vfill
    
    {\large\textbf{Année Universitaire 2025-2026}}
    
    \vspace{0.3cm}
    
    {\large Janvier 2026}
    
\end{titlepage}

% ==================== TABLE DES MATIÈRES ====================
\tableofcontents
\newpage

% ==================== INTRODUCTION ====================
\section{Introduction}

Dans le cadre de notre formation en Master 1 Intelligence Artificielle, nous avons eu l'opportunité de travailler sur un projet passionnant : la création d'un jeu de Mancala à 16 trous doté de plusieurs intelligences artificielles. Ce projet nous a permis de mettre en pratique les concepts théoriques vus en cours, tout en développant nos compétences en programmation C++.

Le Mancala, l'un des plus anciens jeux de stratégie au monde, nous a semblé être le terrain de jeu idéal pour explorer différents algorithmes de recherche. Nous avons choisi de développer notre solution en \textbf{C++17}, un langage qui nous offre à la fois la performance nécessaire pour les calculs intensifs et la flexibilité pour une architecture propre.

\begin{infobox}[Notre Objectif]
Notre ambition était claire : concevoir un bot capable de rivaliser avec un joueur humain expérimenté, tout en gardant un code lisible et maintenable. Nous voulions également comprendre en profondeur comment fonctionnent les algorithmes classiques de l'IA appliqués aux jeux.
\end{infobox}

\subsection{Répartition des Tâches}

Ce projet a été réalisé en binôme, et nous avons veillé à répartir équitablement le travail tout en tirant parti des forces de chacun. Voici comment nous nous sommes organisés :

\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\rowcolor{primarycolor!20}
\textbf{Module} & \textbf{KHALIA Mohamed Mehdi} & \textbf{BEN SALAH Mohamed Dhia} \\
\hline
\textbf{Règles du jeu} & Conception de la logique de jeu & Validation et tests des règles \\
\hline
\textbf{Moteur de jeu} & Implémentation des captures & Gestion du semis et distribution \\
\hline
\textbf{Algorithmes IA} & BFS, DFS, Min-Max & Alpha-Beta, IDDFS \\
\hline
\textbf{Fonction d'évaluation} & Conception initiale & Optimisation et ajustements \\
\hline
\textbf{Interface utilisateur} & Menu principal & Affichage du plateau \\
\hline
\textbf{Tests \& Debug} & Tests unitaires & Tests d'intégration \\
\hline
\textbf{Documentation} & Architecture \& Code & Rédaction du rapport \\
\hline
\end{tabular}
\caption{Répartition des tâches au sein de l'équipe}
\end{table}

Nous avons travaillé en étroite collaboration tout au long du projet, avec des sessions de pair programming régulières pour les parties les plus complexes. Cette approche nous a permis de partager nos connaissances et de produire un code de meilleure qualité.

\subsection{Présentation du Mancala}

Le Mancala fait partie de notre patrimoine ludique mondial --- c'est l'un des plus anciens jeux de stratégie connus ! Pour notre projet, nous avons choisi une variante particulière qui utilise :
\begin{itemize}[leftmargin=2cm]
    \item \textbf{16 trous} numérotés de 1 à 16, disposés en cercle (sens horaire)
    \item \textbf{8 trous par joueur} --- le Joueur 1 contrôle les impairs, le Joueur 2 les pairs
    \item \textbf{3 couleurs de graines} : Rouge, Bleu et Transparent (chacune avec ses propres règles !)
    \item \textbf{96 graines au total} au départ, soit 6 par trou (2 de chaque couleur)
\end{itemize}

Ce qui rend cette variante particulièrement intéressante, c'est la gestion des couleurs : chaque couleur suit des règles de distribution différentes, ce qui augmente considérablement la complexité stratégique du jeu.

\subsection{Algorithmes Implémentés}

Pour donner vie à notre IA, nous avons implémenté cinq algorithmes de recherche. Chacun a ses forces et ses faiblesses, et nous les avons comparés pour déterminer lequel offre le meilleur compromis entre temps de calcul et qualité de jeu.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\rowcolor{primarycolor!20}
\textbf{Algorithme} & \textbf{Profondeur par défaut} & \textbf{Type de recherche} \\
\hline
BFS (Breadth-First Search) & 2 & Largeur d'abord \\
\hline
DFS (Depth-First Search) & 3 & Profondeur d'abord \\
\hline
Min-Max & 4 & Adversariale \\
\hline
Alpha-Beta Pruning & 5 & Adversariale optimisée \\
\hline
Iterative Deepening DFS & 6 & Approfondissement itératif \\
\hline
\end{tabular}
\caption{Algorithmes d'IA disponibles}
\end{table}

% ==================== RÈGLES DU JEU ====================
\section{Règles du Jeu}

Avant de plonger dans les détails techniques, prenons le temps de bien comprendre les règles du jeu. Elles sont essentielles pour saisir les défis auxquels nos algorithmes doivent faire face !

\subsection{Configuration Initiale}

Au début de chaque partie, le plateau se présente ainsi :

\begin{itemize}[leftmargin=2cm]
    \item Le plateau forme un cercle de \textbf{16 trous}
    \item Le \textbf{Joueur 1} est maître des trous impairs : 1, 3, 5, 7, 9, 11, 13, 15
    \item Le \textbf{Joueur 2} contrôle les trous pairs : 2, 4, 6, 8, 10, 12, 14, 16
    \item Chaque trou débute avec \textbf{6 graines} : 2 rouges, 2 bleues et 2 transparentes
\end{itemize}

\subsection{Règles de Semis}

Lors d'un tour, le joueur sélectionne un trou et une couleur :

\begin{warningbox}[Distribution selon la couleur]
\begin{itemize}
    \item \textbf{Graines Rouges (R)} : Distribuées dans \textbf{tous les trous} en sens horaire
    \item \textbf{Graines Bleues (B)} : Distribuées \textbf{uniquement} dans les trous de l'adversaire
    \item \textbf{Graines Transparentes (T)} : Jouées comme Rouge ou Bleu selon le choix du joueur
\end{itemize}
\end{warningbox}

\begin{infobox}[Important - Graines Transparentes]
Lorsque les graines transparentes sont jouées, elles sont distribuées \textbf{avant} les graines de la couleur désignée, mais \textbf{restent transparentes} sur le plateau.
\end{infobox}

\subsection{Règles de Capture}

La capture s'effectue lorsqu'une graine semée porte le total d'un trou à \textbf{exactement 2 ou 3 graines} :

\begin{itemize}[leftmargin=2cm]
    \item Les graines du trou sont capturées (toutes les couleurs)
    \item La capture se propage aux trous précédents si leurs totaux sont également 2 ou 3
    \item On peut capturer ses propres graines
    \item Affamer l'adversaire (prendre toutes ses graines) est \textbf{autorisé}
\end{itemize}

\subsection{Conditions de Fin de Partie}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\rowcolor{primarycolor!20}
\textbf{Condition} & \textbf{Résultat} \\
\hline
Un joueur capture $\geq 49$ graines & Victoire immédiate \\
\hline
Les deux joueurs ont $\geq 40$ graines & Égalité \\
\hline
Moins de 10 graines sur le plateau & Fin (plus de graines $\Rightarrow$ victoire) \\
\hline
400 coups atteints & Fin (plus de graines $\Rightarrow$ victoire) \\
\hline
\end{tabular}
\caption{Conditions de fin de partie}
\end{table}

\subsection{Format des Coups}

Les coups sont exprimés au format \texttt{NC} ou \texttt{NTC} :

\begin{lstlisting}[caption={Exemples de coups}]
14B   -> Trou 14, graines BLEUES
3R    -> Trou 3, graines ROUGES
5TR   -> Trou 5, graines TRANSPARENTES jouees comme ROUGES
8TB   -> Trou 8, graines TRANSPARENTES jouees comme BLEUES
\end{lstlisting}

% ==================== ARCHITECTURE ====================
\section{Architecture du Projet}

L'un des aspects dont nous sommes particulièrement fiers est l'architecture de notre code. Nous avons passé du temps à réfléchir à une structure qui soit à la fois claire et extensible.

\subsection{Structure des Fichiers}

Nous avons opté pour une organisation modulaire, où chaque fichier a une responsabilité bien définie. Cette approche nous a facilité le travail en équipe et le débogage :

\begin{algorithmbox}[Structure des fichiers]
\begin{verbatim}
c_version/
├── main.cpp          # Interface utilisateur et menu principal
├── config.h          # Configuration du jeu et des IA
├── game_rules.h      # Règles du jeu et état du plateau
├── game_engine.h     # Moteur de jeu (exécution des coups, captures)
├── ai_algorithms.h   # Algorithmes d'IA (BFS, DFS, MinMax, etc.)
├── game_manager.h    # Gestionnaire de parties et joueurs
└── README.md         # Documentation
\end{verbatim}
\end{algorithmbox}

\subsection{Diagramme de Classes}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    class/.style={rectangle, draw=primarycolor, fill=primarycolor!10, thick, minimum width=3cm, minimum height=1cm},
    arrow/.style={->, thick, >=stealth}
]
    % Classes principales
    \node[class] (gamestate) at (0, 4) {\textbf{GameState}};
    \node[class] (gameengine) at (4, 4) {\textbf{GameEngine}};
    \node[class] (gamemanager) at (8, 4) {\textbf{GameManager}};
    
    % Classes IA
    \node[class, fill=accentcolor!10, draw=accentcolor] (evaluator) at (0, 2) {\textbf{Evaluator}};
    \node[class, fill=accentcolor!10, draw=accentcolor] (bfs) at (0, 0) {\textbf{BFSBot}};
    \node[class, fill=accentcolor!10, draw=accentcolor] (dfs) at (2.5, 0) {\textbf{DFSBot}};
    \node[class, fill=accentcolor!10, draw=accentcolor] (minmax) at (5, 0) {\textbf{MinMaxBot}};
    \node[class, fill=accentcolor!10, draw=accentcolor] (alphabeta) at (7.5, 0) {\textbf{AlphaBetaBot}};
    \node[class, fill=accentcolor!10, draw=accentcolor] (iddfs) at (10, 0) {\textbf{IDDFSBot}};
    
    % Classes joueurs
    \node[class, fill=green!10, draw=green!50!black] (player) at (8, 2) {\textbf{Player}};
    \node[class, fill=green!10, draw=green!50!black] (aiplayer) at (6, 0.8) {\textbf{AIPlayer}};
    \node[class, fill=green!10, draw=green!50!black] (humanplayer) at (10, 0.8) {\textbf{HumanPlayer}};
    
    % Flèches
    \draw[arrow] (gameengine) -- (gamestate);
    \draw[arrow] (gamemanager) -- (gameengine);
    \draw[arrow] (aiplayer) -- (player);
    \draw[arrow] (humanplayer) -- (player);
    
\end{tikzpicture}
\caption{Diagramme simplifié des classes}
\end{figure}

\subsection{Module game\_rules.h}

Ce module définit les structures de données fondamentales :

\begin{lstlisting}[caption={Enumération des couleurs}]
enum class Color {
    RED,
    BLUE,
    TRANSPARENT
};
\end{lstlisting}

\begin{lstlisting}[caption={Classe GameState - État du jeu}]
class GameState {
public:
    static const int MAX_MOVES = 400;
    
    // Dictionnaire des trous: {numero: {couleur: nombre}}
    std::map<int, std::map<Color, int>> holes;
    std::map<int, int> captured_seeds;  // Graines capturees par joueur
    int current_player;
    int move_count;
    
    void initializeBoard();
    std::vector<int> getPlayerHoles(int player) const;
    int getTotalSeeds(int hole) const;
    int getSeedsOnBoard() const;
    bool isGameOver() const;
    int getWinner() const;
};
\end{lstlisting}

\subsection{Module game\_engine.h}

Le moteur de jeu gère l'exécution des coups et les captures :

\begin{lstlisting}[caption={Méthode principale du moteur de jeu}]
bool playMove(int hole, Color color, 
              Color transparent_as = Color::RED, 
              bool use_transparent = false) {
    // Verification de validite
    // Distribution des graines selon les regles
    // Gestion des captures
    // Changement de joueur
}
\end{lstlisting}

% ==================== ALGORITHMES IA ====================
\section{Algorithmes d'Intelligence Artificielle}

C'est ici que les choses deviennent vraiment intéressantes ! Implémenter ces algorithmes nous a permis de comprendre en profondeur comment une IA peut "réfléchir" à un jeu de stratégie.

\subsection{Fonction d'Évaluation}

Le cœur de notre IA, c'est sa capacité à évaluer une position. Nous avons conçu une fonction d'évaluation qui prend en compte deux facteurs principaux : les graines déjà capturées et le contrôle du plateau.

\begin{equation}
\text{Score}(s, p) = 10 \times (C_p - C_o) + 2 \times (G_p - G_o)
\end{equation}

Où :
\begin{itemize}[leftmargin=2cm]
    \item $C_p$ : Graines capturées par le joueur $p$
    \item $C_o$ : Graines capturées par l'adversaire
    \item $G_p$ : Graines sur le plateau appartenant au joueur $p$
    \item $G_o$ : Graines sur le plateau appartenant à l'adversaire
\end{itemize}

\begin{lstlisting}[caption={Implémentation de la fonction d'évaluation}]
static double evaluate(const GameState& state, int player) {
    int opponent = 3 - player;
    
    // Difference de graines capturees
    double score = (captured.at(player) - captured.at(opponent)) * 10.0;
    
    // Bonus pour les graines sur le plateau
    score += (player_seeds - opponent_seeds) * 2.0;
    
    return score;
}
\end{lstlisting}

\subsection{BFS - Breadth-First Search}

L'algorithme BFS explore tous les états à une profondeur donnée avant de passer à la suivante.

\begin{algorithmbox}[Caractéristiques BFS]
\begin{itemize}
    \item \textbf{Profondeur} : 2 (par défaut)
    \item \textbf{Stratégie} : File d'attente (FIFO)
    \item \textbf{Avantage} : Trouve la solution la plus proche
    \item \textbf{Inconvénient} : Consommation mémoire élevée
\end{itemize}
\end{algorithmbox}

\begin{algorithm}[H]
\caption{BFS pour le Mancala}
\begin{algorithmic}[1]
\State $queue \gets \{(state, 0, \emptyset)\}$
\State $best\_move \gets \emptyset$
\State $best\_score \gets -\infty$
\While{$queue \neq \emptyset$}
    \State $(current, depth, first\_move) \gets queue.pop()$
    \If{$depth = max\_depth$}
        \State $score \gets evaluate(current, player)$
        \If{$score > best\_score$}
            \State $best\_score \gets score$
            \State $best\_move \gets first\_move$
        \EndIf
    \Else
        \ForAll{$move \in validMoves(current)$}
            \State $new\_state \gets apply(current, move)$
            \State $queue.push((new\_state, depth+1, first\_move \lor move))$
        \EndFor
    \EndIf
\EndWhile
\State \Return $best\_move$
\end{algorithmic}
\end{algorithm}

\subsection{DFS - Depth-First Search}

L'algorithme DFS explore chaque branche jusqu'à sa profondeur maximale avant de revenir en arrière.

\begin{algorithmbox}[Caractéristiques DFS]
\begin{itemize}
    \item \textbf{Profondeur} : 3 (par défaut)
    \item \textbf{Stratégie} : Pile (LIFO) / Récursion
    \item \textbf{Avantage} : Faible consommation mémoire
    \item \textbf{Inconvénient} : Peut manquer des solutions proches
\end{itemize}
\end{algorithmbox}

\begin{algorithm}[H]
\caption{DFS pour le Mancala}
\begin{algorithmic}[1]
\Function{DFS}{$state, player, depth$}
    \If{$isTerminal(state)$ \textbf{or} $depth = 0$}
        \State \Return $(evaluate(state, player), \emptyset)$
    \EndIf
    \If{$state.current\_player = player$}
        \State $best \gets -\infty$
        \ForAll{$move \in validMoves(state)$}
            \State $(score, \_) \gets DFS(apply(state, move), player, depth-1)$
            \If{$score > best$}
                \State $best \gets score$
                \State $best\_move \gets move$
            \EndIf
        \EndFor
    \Else
        \State $best \gets +\infty$
        \ForAll{$move \in validMoves(state)$}
            \State $(score, \_) \gets DFS(apply(state, move), player, depth-1)$
            \If{$score < best$}
                \State $best \gets score$
            \EndIf
        \EndFor
    \EndIf
    \State \Return $(best, best\_move)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Min-Max}

L'algorithme Min-Max est un algorithme adversarial qui suppose que l'adversaire joue de manière optimale.

\begin{algorithmbox}[Caractéristiques Min-Max]
\begin{itemize}
    \item \textbf{Profondeur} : 4 (par défaut)
    \item \textbf{Stratégie} : Maximiser notre score, minimiser celui de l'adversaire
    \item \textbf{Avantage} : Optimal contre un adversaire parfait
    \item \textbf{Inconvénient} : Complexité exponentielle $O(b^d)$
\end{itemize}
\end{algorithmbox}

Le principe repose sur l'alternance entre :
\begin{itemize}[leftmargin=2cm]
    \item \textbf{Nœuds MAX} : Le joueur cherche à maximiser son score
    \item \textbf{Nœuds MIN} : L'adversaire cherche à minimiser le score du joueur
\end{itemize}

\subsection{Alpha-Beta Pruning}

L'élagage Alpha-Beta est une optimisation de Min-Max qui élimine les branches inutiles.

\begin{algorithmbox}[Caractéristiques Alpha-Beta]
\begin{itemize}
    \item \textbf{Profondeur} : 5 (par défaut) - \textbf{Recommandé}
    \item \textbf{Optimisation} : Élagage des branches non prometteuses
    \item \textbf{Avantage} : Même résultat que Min-Max, beaucoup plus rapide
    \item \textbf{Complexité} : $O(b^{d/2})$ dans le meilleur cas
\end{itemize}
\end{algorithmbox}

\begin{infobox}[Principe de l'élagage]
\begin{itemize}
    \item $\alpha$ : Meilleure valeur garantie pour le joueur MAX
    \item $\beta$ : Meilleure valeur garantie pour le joueur MIN
    \item \textbf{Coupure $\beta$} : Si $\alpha \geq \beta$ dans un nœud MAX
    \item \textbf{Coupure $\alpha$} : Si $\beta \leq \alpha$ dans un nœud MIN
\end{itemize}
\end{infobox}

\begin{lstlisting}[caption={Implémentation Alpha-Beta}]
std::pair<double, Move> search(const GameState& state, int player, 
                                int depth, double alpha, double beta, 
                                bool is_maximizing) {
    if (isTerminal(state) || depth >= max_depth) {
        return {evaluate(state, player), Move()};
    }
    
    if (is_maximizing) {
        double max_eval = -INFINITY;
        for (const auto& move : validMoves(state)) {
            auto [eval, _] = search(apply(state, move), player, 
                                    depth + 1, alpha, beta, false);
            max_eval = std::max(max_eval, eval);
            alpha = std::max(alpha, eval);
            if (beta <= alpha) break;  // Beta cutoff
        }
        return {max_eval, best_move};
    } else {
        double min_eval = +INFINITY;
        for (const auto& move : validMoves(state)) {
            auto [eval, _] = search(apply(state, move), player, 
                                    depth + 1, alpha, beta, true);
            min_eval = std::min(min_eval, eval);
            beta = std::min(beta, eval);
            if (beta <= alpha) break;  // Alpha cutoff
        }
        return {min_eval, best_move};
    }
}
\end{lstlisting}

\subsection{Iterative Deepening DFS}

L'approfondissement itératif combine les avantages de BFS et DFS en effectuant des recherches DFS successives avec des profondeurs croissantes.

\begin{algorithmbox}[Caractéristiques IDDFS]
\begin{itemize}
    \item \textbf{Profondeur maximale} : 6 (par défaut)
    \item \textbf{Stratégie} : DFS répété avec profondeur croissante
    \item \textbf{Avantage} : Faible mémoire + trouve les meilleures solutions
    \item \textbf{Gestion du temps} : Peut être interrompu à tout moment
\end{itemize}
\end{algorithmbox}

\begin{algorithm}[H]
\caption{Iterative Deepening DFS}
\begin{algorithmic}[1]
\Function{IDDFS}{$state, player, max\_depth$}
    \State $best\_move \gets \emptyset$
    \For{$d \gets 1$ \textbf{to} $max\_depth$}
        \State $(score, move) \gets DFS\_Limited(state, player, d)$
        \If{$move$ is valid}
            \State $best\_move \gets move$
        \EndIf
    \EndFor
    \State \Return $best\_move$
\EndFunction
\end{algorithmic}
\end{algorithm}

% ==================== COMPARAISON ====================
\section{Comparaison des Algorithmes}

\subsection{Complexité Théorique}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor{primarycolor!20}
\textbf{Algorithme} & \textbf{Temps} & \textbf{Espace} & \textbf{Optimal} \\
\hline
BFS & $O(b^d)$ & $O(b^d)$ & Oui (profondeur fixe) \\
\hline
DFS & $O(b^d)$ & $O(d)$ & Non \\
\hline
Min-Max & $O(b^d)$ & $O(d)$ & Oui \\
\hline
Alpha-Beta & $O(b^{d/2})$ à $O(b^d)$ & $O(d)$ & Oui \\
\hline
IDDFS & $O(b^d)$ & $O(d)$ & Oui \\
\hline
\end{tabular}
\caption{Complexité des algorithmes ($b$ = facteur de branchement, $d$ = profondeur)}
\end{table}

\subsection{Recommandations d'Utilisation}

\begin{warningbox}[Choix de l'algorithme]
\begin{itemize}
    \item \textbf{Alpha-Beta (Profondeur 5)} : \textbf{Recommandé} pour un équilibre optimal entre performance et temps de calcul
    \item \textbf{IDDFS (Profondeur 6)} : Pour des parties longues avec gestion du temps
    \item \textbf{Min-Max (Profondeur 4)} : Référence pédagogique
    \item \textbf{BFS/DFS} : Pour comparaison et tests
\end{itemize}
\end{warningbox}

% ==================== COMPILATION ====================
\section{Compilation et Exécution}

\subsection{Prérequis}

\begin{itemize}[leftmargin=2cm]
    \item Compilateur C++17 (GCC $\geq$ 7, Clang $\geq$ 5, MSVC $\geq$ 2017)
    \item CMake 3.10+ (optionnel)
\end{itemize}

\subsection{Compilation avec g++}

\begin{lstlisting}[language=bash, caption={Compilation avec g++}]
g++ -std=c++17 -O2 -o mancala main.cpp
\end{lstlisting}

\subsection{Compilation avec CMake}

\begin{lstlisting}[language=bash, caption={Compilation avec CMake}]
mkdir build
cd build
cmake ..
cmake --build .
\end{lstlisting}

\subsection{Exécution}

\begin{lstlisting}[language=bash, caption={Lancement du jeu}]
./mancala
\end{lstlisting}

\subsection{Modes de Jeu}

Le menu principal propose :

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Jouer contre l'IA} : Mode Humain vs IA
    \item \textbf{IA vs IA} : Observer deux IA s'affronter
    \item \textbf{Tournoi entre IA} : Compétition entre tous les algorithmes
    \item \textbf{Quitter} : Fermer le programme
\end{enumerate}

% ==================== CONCLUSION ====================
\section{Conclusion}

Ce projet a été pour nous une aventure enrichissante ! Nous avons réussi à créer un jeu de Mancala complet avec cinq intelligences artificielles fonctionnelles, et surtout, nous avons énormément appris en chemin.

Travailler sur ce projet nous a permis de :
\begin{itemize}[leftmargin=2cm]
    \item Approfondir notre compréhension des algorithmes de recherche adversariale
    \item Améliorer nos compétences en C++ moderne (C++17)
    \item Apprendre à travailler efficacement en binôme sur un projet de code conséquent
    \item Découvrir les subtilités de l'optimisation pour les jeux de stratégie
\end{itemize}

\subsection{Ce Dont Nous Sommes Fiers}

\begin{itemize}[leftmargin=2cm]
    \item \textbf{Architecture propre} : notre code est lisible et chaque module a sa responsabilité
    \item \textbf{Cinq algorithmes fonctionnels} : du simple BFS au sophistiqué Alpha-Beta
    \item \textbf{Gestion complète des règles} : y compris le cas délicat des graines transparentes
    \item \textbf{Performance} : l'élagage Alpha-Beta rend notre IA réactive
    \item \textbf{Interface claire} : on peut jouer sans lire de documentation !
\end{itemize}

\subsection{Pour Aller Plus Loin}

Si nous avions plus de temps, voici ce que nous aimerions ajouter :

\begin{itemize}[leftmargin=2cm]
    \item \textbf{Tables de transposition} : pour éviter de recalculer des positions déjà vues
    \item \textbf{Monte Carlo Tree Search (MCTS)} : une approche différente qui marche très bien pour les jeux
    \item \textbf{Interface graphique} : pour rendre le jeu plus agréable visuellement
    \item \textbf{Mode en ligne} : pour affronter des joueurs distants
    \item \textbf{Apprentissage par renforcement} : pour que l'IA s'améliore en jouant
\end{itemize}

% ==================== RÉFÉRENCES ====================
\section{Références}

\begin{itemize}[leftmargin=2cm]
    \item Russell, S., \& Norvig, P. (2020). \textit{Artificial Intelligence: A Modern Approach} (4th ed.)
    \item Knuth, D. E., \& Moore, R. W. (1975). An analysis of alpha-beta pruning. \textit{Artificial Intelligence}, 6(4), 293-326.
    \item Documentation C++17 : \url{https://en.cppreference.com/}
\end{itemize}

\end{document}
